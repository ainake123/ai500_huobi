è¿™æ˜¯ä¸€ä¸ªå®Œæ•´çš„ã€å¯ç›´æ¥éƒ¨ç½²çš„å¾®æœåŠ¡å®ç°æ–¹æ¡ˆã€‚åŒ…å«äº† Go åç«¯ä»£ç ï¼ˆå†…ç½® AI500 è®¡ç®—å¼•æ“ï¼‰å’Œ Docker éƒ¨ç½²é…ç½®ã€‚

ğŸ“‚ é¡¹ç›®ç»“æ„
è¯·åœ¨ä½ çš„å·¥ä½œç›®å½•ä¸‹åˆ›å»ºä»¥ä¸‹æ–‡ä»¶ï¼š

Plaintext

ai500-service/
â”œâ”€â”€ Dockerfile
â”œâ”€â”€ docker-compose.yml
â”œâ”€â”€ go.mod
â””â”€â”€ main.go
1. åç«¯ä»£ç  (main.go)
è¿™ä¸ªç¨‹åºä¼šå¯åŠ¨ä¸€ä¸ª HTTP æœåŠ¡ç›‘å¬ 3000 ç«¯å£ï¼Œå¹¶åœ¨åå°æ¯ 10 ç§’ä»ç«å¸æ‹‰å–ä¸€æ¬¡æ•°æ®æ›´æ–°ç¼“å­˜ï¼Œç¡®ä¿ API å“åº”é€Ÿåº¦æå¿«ï¼ˆæ¯«ç§’çº§ï¼‰ã€‚

Go

package main

import (
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"sort"
	"strings"
	"sync"
	"time"
)

// ================= é…ç½® =================

const (
	ServerPort  = ":3000"
	HuobiAPI    = "https://api.hbdm.com/linear-swap-ex/market/detail/batch_merged"
	RefreshRate = 10 * time.Second
)

// AI æ¿å—ç™½åå•
var AiSectorTokens = []string{
	"TAO-USDT", "FET-USDT", "RNDR-USDT", "WLD-USDT", "NEAR-USDT",
	"GRT-USDT", "AGIX-USDT", "OCEAN-USDT", "AKT-USDT", "PHB-USDT",
	"NMR-USDT", "AI-USDT", "NFP-USDT", "CYBER-USDT", "ICP-USDT",
	"THETA-USDT", "JASMY-USDT", "RENDER-USDT", "ARKM-USDT",
}

// ================= æ•°æ®ç»“æ„ =================

// API å“åº”ç»“æ„
type APIResponse struct {
	Timestamp int64       `json:"timestamp"`
	Index     float64     `json:"index_value"`
	Count     int         `json:"count"`
	Data      []AssetItem `json:"list"`
}

type AssetItem struct {
	Rank   int     `json:"rank"`
	Symbol string  `json:"symbol"`
	Price  float64 `json:"price"`
	Volume float64 `json:"volume_24h_usd"` // ä¼°ç®—æˆäº¤é¢
}

// å…¨å±€ç¼“å­˜ (çº¿ç¨‹å®‰å…¨)
var (
	cache      APIResponse
	cacheMutex sync.RWMutex
)

// ================= ä¸»ç¨‹åº =================

func main() {
	// 1. å¯åŠ¨åå°æ•°æ®æ›´æ–°åç¨‹
	go backgroundFetcher()

	// 2. è®¾ç½® HTTP è·¯ç”±
	http.HandleFunc("/api/ai500/list", handleAI500List)

	// 3. å¯åŠ¨æœåŠ¡å™¨
	fmt.Printf("ğŸš€ AI500 Service running at http://127.0.0.1%s/api/ai500/list\n", ServerPort)
	if err := http.ListenAndServe(ServerPort, nil); err != nil {
		log.Fatal(err)
	}
}

// ================= å¤„ç†é€»è¾‘ =================

// HTTP Handler
func handleAI500List(w http.ResponseWriter, r *http.Request) {
	// å…è®¸è·¨åŸŸ (CORS) - æ–¹ä¾¿å‰ç«¯è°ƒç”¨
	w.Header().Set("Access-Control-Allow-Origin", "*")
	w.Header().Set("Content-Type", "application/json")

	cacheMutex.RLock()
	data := cache
	cacheMutex.RUnlock()

	// å¦‚æœç¼“å­˜ä¸ºç©ºï¼ˆæœåŠ¡åˆšå¯åŠ¨ï¼‰ï¼Œè¿”å›æç¤º
	if data.Timestamp == 0 {
		http.Error(w, `{"error": "Data initializing..."}`, http.StatusServiceUnavailable)
		return
	}

	json.NewEncoder(w).Encode(data)
}

// åå°å¾ªç¯æŠ“å–
func backgroundFetcher() {
	// ç«‹å³æ‰§è¡Œä¸€æ¬¡ï¼Œç„¶åå®šæ—¶
	updateData()
	ticker := time.NewTicker(RefreshRate)
	for range ticker.C {
		updateData()
	}
}

// æ ¸å¿ƒé€»è¾‘ï¼šä»ç«å¸è·å–å¹¶è®¡ç®—
func updateData() {
	// 1. è·å–ç«å¸æ‰€æœ‰è¡Œæƒ…
	ticks, err := fetchHuobiMarket()
	if err != nil {
		log.Printf("Error fetching Huobi data: %v", err)
		return
	}

	// 2. ç­›é€‰å’Œè®¡ç®—
	whitelist := make(map[string]bool)
	for _, t := range AiSectorTokens {
		whitelist[t] = true
	}

	var items []AssetItem
	var totalIndex float64

	for _, t := range ticks {
		if whitelist[t.ContractCode] {
			// ç«å¸ amount æ˜¯å¸æ•°ï¼Œvol æ˜¯å¼ æ•°ã€‚ä¼°ç®— USD æˆäº¤é¢ = amount * price
			volUSD := t.Amount * t.Close
			
			items = append(items, AssetItem{
				Symbol: t.ContractCode,
				Price:  t.Close,
				Volume: volUSD,
			})
			totalIndex += t.Close
		}
	}

	// 3. æ’åº (æŒ‰æˆäº¤é¢é™åº)
	sort.Slice(items, func(i, j int) bool {
		return items[i].Volume > items[j].Volume
	})

	// 4. å¡«å……æ’å
	for i := range items {
		items[i].Rank = i + 1
	}

	// 5. æ›´æ–°ç¼“å­˜
	newResp := APIResponse{
		Timestamp: time.Now().Unix(),
		Index:     totalIndex,
		Count:     len(items),
		Data:      items,
	}

	cacheMutex.Lock()
	cache = newResp
	cacheMutex.Unlock()
	
	log.Printf("Updated AI500 data. Index: %.2f, Count: %d", totalIndex, len(items))
}

// ================= ç«å¸ API å·¥å…· =================

type HuobiTicker struct {
	ContractCode string  `json:"contract_code"`
	Close        float64 `json:"close"`
	Amount       float64 `json:"amount"` // æˆäº¤é‡(å¸)
}

type HuobiResponse struct {
	Ticks []HuobiTicker `json:"ticks"`
}

func fetchHuobiMarket() ([]HuobiTicker, error) {
	client := http.Client{Timeout: 5 * time.Second}
	resp, err := client.Get(HuobiAPI)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	body, _ := io.ReadAll(resp.Body)
	var hResp HuobiResponse
	if err := json.Unmarshal(body, &hResp); err != nil {
		return nil, err
	}
	return hResp.Ticks, nil
}
2. åˆå§‹åŒ– Go æ¨¡å— (go.mod)
è¿è¡Œä»¥ä¸‹å‘½ä»¤ç”Ÿæˆ go.mod æ–‡ä»¶ï¼ˆæˆ–è€…æ‰‹åŠ¨åˆ›å»ºï¼‰ï¼š

Bash

go mod init ai500-service
(å¦‚æœæ²¡æœ‰ Go ç¯å¢ƒï¼Œä½ å¯ä»¥ç›´æ¥åˆ›å»ºåä¸º go.mod çš„æ–‡ä»¶ï¼Œå†…å®¹å¦‚ä¸‹):

Plaintext

module ai500-service

go 1.21
3. Docker æ„å»ºæ–‡ä»¶ (Dockerfile)
ä½¿ç”¨å¤šé˜¶æ®µæ„å»ºï¼Œç”Ÿæˆçš„é•œåƒä½“ç§¯æå°ï¼ˆçº¦ 15MBï¼‰ã€‚

Dockerfile

# ç¬¬ä¸€é˜¶æ®µï¼šç¼–è¯‘
FROM golang:1.21-alpine AS builder

WORKDIR /app

# å¤åˆ¶ä¾èµ–é…ç½®
COPY go.mod ./
# ä¸‹è½½ä¾èµ– (å¦‚æœæœ‰ external lib)
# RUN go mod download

# å¤åˆ¶æºç 
COPY . .

# ç¼–è¯‘ (CGO_ENABLED=0 ç¡®ä¿ç”Ÿæˆé™æ€äºŒè¿›åˆ¶æ–‡ä»¶)
RUN CGO_ENABLED=0 GOOS=linux go build -o server main.go

# ç¬¬äºŒé˜¶æ®µï¼šè¿è¡Œ
FROM alpine:latest

# å®‰è£… CA è¯ä¹¦ï¼Œå¦åˆ™æ— æ³•è¯·æ±‚ HTTPS (ç«å¸æ¥å£)
RUN apk --no-cache add ca-certificates

WORKDIR /root/

# ä»ç¼–è¯‘é˜¶æ®µå¤åˆ¶äºŒè¿›åˆ¶æ–‡ä»¶
COPY --from=builder /app/server .

# æš´éœ²ç«¯å£
EXPOSE 3000

# å¯åŠ¨å‘½ä»¤
CMD ["./server"]
4. Docker Compose é…ç½® (docker-compose.yml)
ç”¨äºä¸€é”®å¯åŠ¨æœåŠ¡ã€‚

YAML

version: '3.8'

services:
  ai500-api:
    build: .
    container_name: ai500-service
    ports:
      - "3000:3000"
    restart: always
    environment:
      - TZ=Asia/Shanghai  # è®¾ç½®æ—¶åŒº
    networks:
      - ai_net

networks:
  ai_net:
    driver: bridge
ğŸš€ å¦‚ä½•éƒ¨ç½²å’Œè¿è¡Œ
1. å¯åŠ¨æœåŠ¡
åœ¨åŒ…å«ä¸Šè¿°æ–‡ä»¶çš„ç›®å½•ä¸‹è¿è¡Œï¼š

Bash

docker-compose up -d --build
2. æµ‹è¯• API
æœåŠ¡å¯åŠ¨åï¼Œåœ¨æµè§ˆå™¨æˆ–ç»ˆç«¯è®¿é—®ï¼š

URL: http://127.0.0.1:3000/api/ai500/list

CURL æµ‹è¯•:

Bash

curl http://127.0.0.1:3000/api/ai500/list
3. é¢„æœŸè¿”å›ç»“æœ (JSON)
JSON

{
  "timestamp": 1715068000,
  "index_value": 125.43,
  "count": 19,
  "list": [
    {
      "rank": 1,
      "symbol": "RNDR-USDT",
      "price": 10.52,
      "volume_24h_usd": 250000000.5
    },
    {
      "rank": 2,
      "symbol": "FET-USDT",
      "price": 2.1,
      "volume_24h_usd": 120000000.0
    }
    // ... æ›´å¤šæ•°æ®
  ]
}
âœ… æ–¹æ¡ˆç‰¹ç‚¹
å¼€ç®±å³ç”¨ï¼šåŒ…å«äº†æ‰€æœ‰å¿…è¦çš„ç»„ä»¶ã€‚

é«˜æ€§èƒ½ï¼šé‡‡ç”¨ Go çš„å¹¶å‘ç‰¹æ€§ï¼Œæ•°æ®æ›´æ–°ä¸é˜»å¡ API è¯·æ±‚ã€‚

é›¶ä¾èµ–ï¼šæ²¡æœ‰ä½¿ç”¨ Redis æˆ– æ•°æ®åº“ï¼Œæ•°æ®å¸¸é©»å†…å­˜ï¼Œéƒ¨ç½²æå…¶ç®€å•ã€‚

é˜²æ–­è¿ï¼šå†…ç½®äº† ca-certificatesï¼Œé˜²æ­¢åœ¨ Docker å®¹å™¨å†…è¯·æ±‚ç«å¸ HTTPS æŠ¥é”™ã€‚